# ============================================
# HeatValve-6 : DRV8837 Motor Driver (3x Single H-Bridge)
# ============================================
# Multiplexed motor control for 6 motors using 3x DRV8837
# with GAQY212GSX optocouplers for negative rail switching.
#
# Current sensing inspired by VdMot Controller (Lenti84):
# https://github.com/Lenti84/VdMot_Controller
#
# IMPORTANT: Only ONE motor can run at a time due to the
# multiplexed design (odd vs even motors share negative rails).
#
# DRV8837 pinout: IN1, IN2 (direction), nSLEEP (enable), OUT1, OUT2
# DRV8837 has NO separate standby pin - nSLEEP IS the enable.
#
# Motor mapping:
#   Motor 1: DRV8837#1 (nSLEEP=GPIO11), Mux=HIGH (odd)
#   Motor 2: DRV8837#1 (nSLEEP=GPIO11), Mux=LOW  (even)
#   Motor 3: DRV8837#2 (nSLEEP=GPIO3),  Mux=HIGH (odd)
#   Motor 4: DRV8837#2 (nSLEEP=GPIO3),  Mux=LOW  (even)
#   Motor 5: DRV8837#3 (nSLEEP=GPIO4),  Mux=HIGH (odd)
#   Motor 6: DRV8837#3 (nSLEEP=GPIO4),  Mux=LOW  (even)

# ============================================
# Motor Control Globals
# ============================================
globals:
  - id: motor_mutex
    type: bool
    initial_value: 'false'
    
  - id: current_motor
    type: int
    initial_value: '0'
    
  - id: motor_direction
    type: int
    initial_value: '0'  # 0=close, 1=open
    
  - id: motor_turning
    type: bool
    initial_value: 'false'
    
  - id: motor_debounce_count
    type: int
    initial_value: '0'
    
  # Current measurement (filtered)
  - id: motor_current_raw
    type: float
    initial_value: '0.0'
    
  - id: motor_current_filtered
    type: float
    initial_value: '0.0'
    
  # Mean current accumulator for learning
  - id: motor_current_sum
    type: float
    initial_value: '0.0'
    
  - id: motor_current_count
    type: int
    initial_value: '0'
    
  # Mean current for endstop detection (per motor, in mA)
  # Initial value ~80mA typical for BEMF valve motors
  # These are learned during operation and saved to flash
  - id: motor_mean_current_1
    type: float
    restore_value: true
    initial_value: '80.0'
  - id: motor_mean_current_2
    type: float
    restore_value: true
    initial_value: '80.0'
  - id: motor_mean_current_3
    type: float
    restore_value: true
    initial_value: '80.0'
  - id: motor_mean_current_4
    type: float
    restore_value: true
    initial_value: '80.0'
  - id: motor_mean_current_5
    type: float
    restore_value: true
    initial_value: '80.0'
  - id: motor_mean_current_6
    type: float
    restore_value: true
    initial_value: '80.0'
    
  # Endstop event flag
  - id: motor_endstop_event
    type: bool
    initial_value: 'false'

# ============================================
# Control Parameters
# ============================================
number:
  - platform: template
    name: "Current Factor Low"
    id: ${id_prefix}current_factor_low
    icon: "mdi:current-ac"
    optimistic: true
    min_value: 1.0
    max_value: 4.0
    step: 0.1
    restore_value: true
    initial_value: 1.7
    entity_category: config
    web_server:
      sorting_group_id: sorting_group_settings
      
  - platform: template
    name: "Current Factor High"
    id: ${id_prefix}current_factor_high
    icon: "mdi:current-ac"
    optimistic: true
    min_value: 1.0
    max_value: 4.0
    step: 0.1
    restore_value: true
    initial_value: 1.7
    entity_category: config
    web_server:
      sorting_group_id: sorting_group_settings
      
  - platform: template
    name: "Undercurrent Threshold"
    id: ${id_prefix}undercurrent_threshold
    icon: "mdi:current-ac"
    unit_of_measurement: "mA"
    optimistic: true
    min_value: 1
    max_value: 20
    step: 1
    restore_value: true
    initial_value: 2
    entity_category: config
    web_server:
      sorting_group_id: sorting_group_settings


# ============================================
# GPIO Control Switches
# ============================================
switch:
  # Direction control (IN1 on all DRV8837 - direct)
  - platform: gpio
    name: "Motor Direction 1"
    id: motor_dir1
    pin:
      number: ${motor_dir1_pin}
    internal: true
    restore_mode: ALWAYS_OFF

  # Direction control (IN2 on all DRV8837 - inverted by software)
  - platform: gpio
    name: "Motor Direction 2"
    id: motor_dir2
    pin:
      number: ${motor_dir2_pin}
    internal: true
    restore_mode: ALWAYS_OFF
    
  # Mux control (HIGH = N1/odd motors, LOW = N2/even motors)
  - platform: gpio
    name: "Motor Mux"
    id: motor_mux
    pin:
      number: ${motor_mux_pin}
    internal: true
    restore_mode: ALWAYS_OFF
    
  # nSLEEP / Enable pins (one per DRV8837, active HIGH)
  # DRV8837: nSLEEP=LOW → sleep mode (disabled), nSLEEP=HIGH → active
  - platform: gpio
    name: "Enable Motor 1-2"
    id: motor_ena0
    pin:
      number: ${motor_ena0_pin}
    internal: true
    restore_mode: ALWAYS_OFF  # Sleep at boot (motors disabled)
    
  - platform: gpio
    name: "Enable Motor 3-4"
    id: motor_ena1
    pin:
      number: ${motor_ena1_pin}
    internal: true
    restore_mode: ALWAYS_OFF
    
  - platform: gpio
    name: "Enable Motor 5-6"
    id: motor_ena2
    pin:
      number: ${motor_ena2_pin}
    internal: true
    restore_mode: ALWAYS_OFF

# ============================================
# INA219 Current Sensing (I2C, 100mΩ shunt on MCOM)
# ============================================
sensor:
  # INA219 high-side current sense amplifier
  # Measures motor current through 100mΩ shunt resistor on MCOM rail
  - platform: ina219
    address: 0x40
    shunt_resistance: 0.1 ohm
    max_current: 1.0A
    update_interval: 100ms
    current:
      name: "Motor Current INA219"
      id: ${id_prefix}motor_current_ina219
      accuracy_decimals: 1
      unit_of_measurement: "mA"
      icon: "mdi:current-ac"
      entity_category: diagnostic
      filters:
        - multiply: 1000  # A → mA
      web_server:
        sorting_group_id: sorting_group_debug
    shunt_voltage:
      name: "Motor Shunt Voltage"
      id: ${id_prefix}motor_shunt_voltage
      accuracy_decimals: 4
      entity_category: diagnostic
      internal: true

  # Filtered current in mA (for display and endstop detection)
  - platform: template
    name: "Motor Current"
    id: ${id_prefix}motor_current_ma
    icon: "mdi:current-ac"
    unit_of_measurement: "mA"
    accuracy_decimals: 1
    update_interval: 100ms
    entity_category: diagnostic
    lambda: |-
      return id(motor_current_filtered);
    web_server:
      sorting_group_id: sorting_group_debug
      
  # Mean current of currently running motor (for display)
  - platform: template
    name: "Motor Mean Current"
    id: ${id_prefix}motor_mean_current
    icon: "mdi:current-ac"
    unit_of_measurement: "mA"
    accuracy_decimals: 1
    update_interval: 1s
    entity_category: diagnostic
    lambda: |-
      int motor = id(current_motor);
      if (motor == 0) return 0;
      switch(motor) {
        case 1: return id(motor_mean_current_1);
        case 2: return id(motor_mean_current_2);
        case 3: return id(motor_mean_current_3);
        case 4: return id(motor_mean_current_4);
        case 5: return id(motor_mean_current_5);
        case 6: return id(motor_mean_current_6);
        default: return 0;
      }
    web_server:
      sorting_group_id: sorting_group_debug

# ============================================
# Tacho Input (for revolution counting)
# ============================================
binary_sensor:
  - platform: gpio
    name: "Motor Tacho"
    id: motor_tacho
    pin:
      number: ${tacho_pin}
      mode: INPUT
      inverted: true  # LMV358 Schmitt trigger output is active-high
    internal: true
    filters:
      - delayed_on: 1ms
      
  # Global endstop sensor (triggered by overcurrent)
  - platform: template
    name: "Motor Endstop"
    id: motor_endstop_sensor
    icon: "mdi:stop-circle"
    entity_category: diagnostic
    lambda: |-
      return id(motor_endstop_event);
    web_server:
      sorting_group_id: sorting_group_debug
      
  # Motor turning indicator
  - platform: template
    name: "Motor Turning"
    id: motor_turning_sensor
    icon: "mdi:rotate-3d-variant"
    entity_category: diagnostic
    lambda: |-
      return id(motor_turning);
    web_server:
      sorting_group_id: sorting_group_debug

# ============================================
# Current Measurement & Endstop Detection
# ============================================
# This interval runs at 10ms (100Hz)
# INA219 provides calibrated mA readings via I2C (no ADC/ref needed)
interval:
  - interval: 10ms
    then:
      - lambda: |-
          // Only process when motor is turning
          if (!id(motor_turning)) {
            id(motor_current_filtered) = 0;
            id(motor_debounce_count) = 0;
            return;
          }
          
          // Read current from INA219 (already in mA via multiply filter)
          float raw_current = id(${id_prefix}motor_current_ina219).state;
          if (isnan(raw_current)) raw_current = 0;
          id(motor_current_raw) = raw_current;
          
          // Filter: IIR low-pass (98% old + 2% new)
          float filtered = id(motor_current_filtered) * 0.98 + abs(raw_current) * 0.02;
          id(motor_current_filtered) = filtered;
          
          // Debounce counter (ignore motor inrush current)
          if (id(motor_debounce_count) < 255) {
            id(motor_debounce_count)++;
          }
          
          // Only check after debounce period (~250ms at 10ms interval)
          if (id(motor_debounce_count) < 25) {
            return;
          }
          
          // Get mean current for this motor
          int motor = id(current_motor);
          float mean_current = 80.0;  // default for BEMF valve motors
          switch(motor) {
            case 1: mean_current = id(motor_mean_current_1); break;
            case 2: mean_current = id(motor_mean_current_2); break;
            case 3: mean_current = id(motor_mean_current_3); break;
            case 4: mean_current = id(motor_mean_current_4); break;
            case 5: mean_current = id(motor_mean_current_5); break;
            case 6: mean_current = id(motor_mean_current_6); break;
          }
          
          // Calculate thresholds
          float factor_high = id(${id_prefix}current_factor_high).state;
          float factor_low = id(${id_prefix}current_factor_low).state;
          float threshold_high = mean_current * factor_high;
          float undercurrent = id(${id_prefix}undercurrent_threshold).state;
          
          // Debug: log every 50 cycles (~500ms) during motor operation
          static int debug_cycle = 0;
          debug_cycle++;
          if (debug_cycle >= 50) {
            debug_cycle = 0;
            ESP_LOGI("motor", "Motor %d: raw=%.1fmA filtered=%.1fmA mean=%.1fmA thr=%.1fmA",
                     motor, raw_current, filtered, mean_current, threshold_high);
          }
          
          // Overcurrent / endstop detection
          // Only use FILTERED current (raw is too noisy)
          // Safety limit at 250mA absolute
          if (filtered > threshold_high || filtered > 250.0) {
            ESP_LOGI("motor", "Endstop: filtered=%.1f mA (threshold=%.1f)", filtered, threshold_high);
            id(motor_endstop_event) = true;
          }
          
          // Undercurrent detection (no motor connected)
          else if (filtered < undercurrent) {
            static int undercurrent_count = 0;
            undercurrent_count++;
            if (undercurrent_count > 100) {  // 1000ms of undercurrent
              ESP_LOGW("motor", "Undercurrent: filtered=%.1f mA (Motor %d) - no motor?", filtered, motor);
              undercurrent_count = 0;
              id(motor_endstop_event) = true;
            }
          }
          
          // Normal operation: accumulate for mean current calculation
          else {
            id(motor_current_sum) += filtered;
            id(motor_current_count)++;
          }

# ============================================
# Test Buttons (for debugging)
# ============================================
button:
  - platform: template
    name: "Test Motor 1 Open"
    icon: mdi:arrow-up
    on_press:
      - script.execute:
          id: motor_start
          motor_num: 1
          direction: 1
      - delay: 10s
      - script.execute:
          id: motor_stop
          motor_num: 1
    entity_category: diagnostic
    web_server:
      sorting_group_id: sorting_group_debug

  - platform: template
    name: "Test Motor 1 Close"
    icon: mdi:arrow-down
    on_press:
      - script.execute:
          id: motor_start
          motor_num: 1
          direction: 0
      - delay: 10s
      - script.execute:
          id: motor_stop
          motor_num: 1
    entity_category: diagnostic
    web_server:
      sorting_group_id: sorting_group_debug

  - platform: template
    name: "Stop All Motors"
    icon: mdi:stop
    on_press:
      - script.execute: motor_stop_all
    entity_category: diagnostic
    web_server:
      sorting_group_id: sorting_group_debug

# ============================================
# Motor Control Scripts
# ============================================
script:
  # Stop all motors immediately
  - id: motor_stop_all
    then:
      - switch.turn_off: motor_ena0
      - switch.turn_off: motor_ena1
      - switch.turn_off: motor_ena2
      - switch.turn_off: motor_dir1
      - switch.turn_off: motor_dir2
      - globals.set:
          id: motor_turning
          value: 'false'
      - globals.set:
          id: motor_mutex
          value: 'false'
      - globals.set:
          id: current_motor
          value: '0'
      - globals.set:
          id: motor_endstop_event
          value: 'false'
      - script.execute: led_update_status  # Update LED
      - logger.log:
          format: "All motors stopped"
          level: INFO
          tag: motor

  # Start motor with specified number and direction
  - id: motor_start
    parameters:
      motor_num: int
      direction: int
    then:
      - lambda: |-
          // Check if another motor is running
          if (id(motor_mutex)) {
            ESP_LOGW("motor", "Motor %d already running, cannot start motor %d", 
                     id(current_motor), motor_num);
            return;
          }
          
          // Set mutex and state
          id(motor_mutex) = true;
          id(current_motor) = motor_num;
          id(motor_direction) = direction;
          id(motor_endstop_event) = false;
          id(motor_debounce_count) = 0;
          id(motor_current_sum) = 0;
          id(motor_current_count) = 0;
          
          ESP_LOGI("motor", "Starting motor %d, direction=%s", 
                   motor_num, direction ? "OPEN" : "CLOSE");
                   
      # Set mux based on odd/even motor
      - lambda: |-
          bool is_odd = (id(current_motor) % 2) == 1;
          if (is_odd) {
            id(motor_mux).turn_on();  // HIGH for odd motors (N1)
          } else {
            id(motor_mux).turn_off(); // LOW for even motors (N2)
          }
      - delay: 50ms  # Wait for relay/optocoupler settling
      
      # Set direction (IN1 and IN2 must be opposite for DRV8837)
      # DRV8837: IN1=H/IN2=L → Forward, IN1=L/IN2=H → Reverse
      - lambda: |-
          if (id(motor_direction) == 1) {
            id(motor_dir1).turn_on();   // IN1 = HIGH
            id(motor_dir2).turn_off();  // IN2 = LOW  → Forward (open)
          } else {
            id(motor_dir1).turn_off();  // IN1 = LOW
            id(motor_dir2).turn_on();   // IN2 = HIGH → Reverse (close)
          }
      - delay: 5ms
      
      # Mark as turning (enables current measurement)
      - globals.set:
          id: motor_turning
          value: 'true'
      - script.execute: led_status_motor  # Cyan LED for motor running
      
      # Wake up the correct DRV8837 (nSLEEP → HIGH)
      - lambda: |-
          int motor = id(current_motor);
          if (motor == 1 || motor == 2) {
            id(motor_ena0).turn_on();  // DRV8837 #1
          } else if (motor == 3 || motor == 4) {
            id(motor_ena1).turn_on();  // DRV8837 #2
          } else if (motor == 5 || motor == 6) {
            id(motor_ena2).turn_on();  // DRV8837 #3
          }

  # Stop specific motor and update mean current
  - id: motor_stop
    parameters:
      motor_num: int
    then:
      - lambda: |-
          if (id(current_motor) != motor_num && id(motor_mutex)) {
            ESP_LOGW("motor", "Motor %d not running (current=%d)", 
                     motor_num, id(current_motor));
            return;
          }
          
          // Update mean current if we have enough samples
          if (id(motor_current_count) > 20) {
            float new_mean = id(motor_current_sum) / id(motor_current_count);
            // Blend with existing mean (80% old, 20% new)
            float* mean_ptr = nullptr;
            switch(motor_num) {
              case 1: mean_ptr = &id(motor_mean_current_1); break;
              case 2: mean_ptr = &id(motor_mean_current_2); break;
              case 3: mean_ptr = &id(motor_mean_current_3); break;
              case 4: mean_ptr = &id(motor_mean_current_4); break;
              case 5: mean_ptr = &id(motor_mean_current_5); break;
              case 6: mean_ptr = &id(motor_mean_current_6); break;
            }
            if (mean_ptr != nullptr && new_mean > 5.0) {  // Only update if reasonable
              *mean_ptr = (*mean_ptr) * 0.8 + new_mean * 0.2;
              ESP_LOGI("motor", "Motor %d mean current updated: %.1f mA", motor_num, *mean_ptr);
            }
          }
          
          ESP_LOGI("motor", "Stopping motor %d", motor_num);
          
      # Stop turning flag first
      - globals.set:
          id: motor_turning
          value: 'false'
          
      # Put DRV8837 back to sleep (nSLEEP → LOW)
      - lambda: |-
          int motor = motor_num;
          if (motor == 1 || motor == 2) {
            id(motor_ena0).turn_off();  // DRV8837 #1 → sleep
          } else if (motor == 3 || motor == 4) {
            id(motor_ena1).turn_off();  // DRV8837 #2 → sleep
          } else if (motor == 5 || motor == 6) {
            id(motor_ena2).turn_off();  // DRV8837 #3 → sleep
          }
      
      # Clear state
      - globals.set:
          id: motor_mutex
          value: 'false'
      - globals.set:
          id: current_motor
          value: '0'
      - globals.set:
          id: motor_endstop_event
          value: 'false'
